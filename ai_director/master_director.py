# ai_director/master_director.py - UPDATED
from typing import List, Dict, Tuple
from ai_director.data_models import TimelineEvent, DirectorTask
from ai_director.specialists import SpecialistManager
from utils.timestamp_processor import parse_timestamp_line
import numpy as np

class MasterDirector:
    """Orchestrates the AI-driven video editing process."""

    def __init__(self, log_func=None, detailed_logs=False): # New parameter
        self.log_func = log_func or print
        self.specialists = SpecialistManager(log_func=self.log_func)
        self.detailed_logs = detailed_logs # Store the setting
        self.log_func("ðŸ‘‘ AI Master Director initialized.")

    def analyze_video_and_create_timeline(
        self,
        video_duration: float,
        mic_transcription: List[str],
        onomatopoeia_events: List[Dict],
        audio_events: List[Dict]
    ) -> List[TimelineEvent]:
        """
        Main orchestration method. Analyzes all data and produces a final
        decision timeline for the video editor.
        """
        self.log_func("--- AI Director: Starting Full Analysis ---")

        context_map = self._full_scan_analysis(video_duration, mic_transcription, onomatopoeia_events)
        self.log_func(f"Context map created with {len(context_map)} distinct periods.")

        tasks = self._event_driven_analysis(video_duration, mic_transcription, audio_events, context_map)
        self.log_func(f"Generated {len(tasks)} tasks for specialists.")

        full_transcript_text = " ".join([line.split(":", 1)[1] for line in mic_transcription if ":" in line])
        responses = [self.specialists.dispatch_task(task, full_transcript_text) for task in tasks]

        timeline = self._resolve_conflicts_and_build_timeline(responses, tasks)
        self.log_func(f"âœ… AI Director analysis complete. Generated {len(timeline)} timeline events.")

        return timeline

    def _full_scan_analysis(
        self,
        video_duration: float,
        mic_transcription: List[str],
        onomatopoeia_events: List[Dict]
    ) -> Dict[str, any]:
        """
        Performs a high-level analysis of the entire video to create a
        contextual map of energy and activity. (Placeholder logic)
        """
        return {"energy": "mixed"}

    def _event_driven_analysis(
        self,
        video_duration: float,
        mic_transcription: List[str],
        audio_events: List[Dict],
        context_map: Dict[str, any]
    ) -> List[DirectorTask]:
        """
        Generates analysis tasks based on chronological events.
        """
        tasks = []
        window_size = 12.0
        step_size = 6.0

        for start_time in np.arange(0, video_duration - window_size, step_size):
            end_time = start_time + window_size
            tasks.append(DirectorTask(
                task_type="analyze_text_content",
                time_range=(start_time, end_time),
                priority="medium",
                context={"video_duration": video_duration}
            ))
            
        for event in audio_events:
            if event.get('tier') == 'major' or event.get('energy', 0) > 0.7:
                tasks.append(DirectorTask(
                    task_type="analyze_audio_event",
                    time_range=(event['start_time'], event['end_time']),
                    priority="high",
                    context=event
                ))

        return tasks

    def _resolve_conflicts_and_build_timeline(
        self,
        responses: List,
        tasks: List[DirectorTask]
    ) -> List[TimelineEvent]:
        """
        Resolves overlapping recommendations and builds the final timeline.
        Now includes detailed logging.
        """
        events = []
        if self.detailed_logs:
            self.log_func("\n--- AI Director: Specialist Responses ---")
            
        for response, task in zip(responses, tasks):
            if response.result != "no_significant_event" and response.recommended_action:
                event = TimelineEvent(
                    timestamp=task.time_range[0],
                    action=response.recommended_action,
                    duration=3.0,
                    reason=response.result,
                    confidence=response.confidence,
                    source_task_id=response.task_id
                )
                events.append(event)
                if self.detailed_logs:
                    self.log_func(f"  - Event Generated: {event.action} at {event.timestamp:.2f}s (Reason: {event.reason}, Conf: {event.confidence:.2f})")

        if not events:
            if self.detailed_logs:
                self.log_func("  - No significant events generated by specialists.")
            return []

        events.sort(key=lambda e: e.timestamp)
        
        if self.detailed_logs:
            self.log_func("\n--- AI Director: Conflict Resolution ---")

        if not events:
            return []
            
        final_timeline = [events[0]]
        if self.detailed_logs:
            self.log_func(f"  - Initial Event: Keeping {final_timeline[0].action} at {final_timeline[0].timestamp:.2f}s.")

        for current_event in events[1:]:
            last_event = final_timeline[-1]
            
            if current_event.timestamp < last_event.timestamp + last_event.duration:
                priority_map = {"wild_content_detected": 2, "awkward_content_detected": 1, "dramatic_moment_detected": 1}
                current_priority = priority_map.get(current_event.reason, 0)
                last_priority = priority_map.get(last_event.reason, 0)
                
                log_prefix = f"  - Conflict at {current_event.timestamp:.2f}s:"
                
                if current_priority > last_priority:
                    if self.detailed_logs:
                        self.log_func(f"{log_prefix} Replacing '{last_event.action}' with '{current_event.action}' (Higher Priority).")
                    final_timeline[-1] = current_event
                elif current_priority == last_priority and current_event.confidence > last_event.confidence:
                    if self.detailed_logs:
                        self.log_func(f"{log_prefix} Replacing '{last_event.action}' with '{current_event.action}' (Higher Confidence).")
                    final_timeline[-1] = current_event
                else:
                    if self.detailed_logs:
                        self.log_func(f"{log_prefix} Ignoring '{current_event.action}' (Lower Priority/Confidence).")
            else:
                if self.detailed_logs:
                    self.log_func(f"  - No Conflict: Keeping {current_event.action} at {current_event.timestamp:.2f}s.")
                final_timeline.append(current_event)
                
        return final_timeline