# ai_director/master_director.py
from typing import List, Dict, Tuple
from ai_director.data_models import TimelineEvent, DirectorTask
from ai_director.specialists import SpecialistManager
import numpy as np

class MasterDirector:
    """Orchestrates the AI-driven video editing process."""

    def __init__(self, log_func=None, detailed_logs=False):
        self.log_func = log_func or print
        self.specialists = SpecialistManager(log_func=self.log_func)
        self.detailed_logs = detailed_logs
        self.log_func("ðŸ‘‘ AI Master Director initialized.")

    def analyze_video_and_create_timeline(
        self,
        video_path: str,
        video_duration: float,
        mic_transcription: List[str],
        audio_events: List[Dict],
        video_analysis_map: Dict[float, Dict]
    ) -> List[TimelineEvent]:
        self.log_func("--- AI Director: Starting Full Analysis ---")
        tasks = self._event_driven_analysis(video_duration, audio_events)
        self.log_func(f"Generated {len(tasks)} tasks for specialists.")
        full_transcript_text = " ".join([line.split(":", 1)[1] for line in mic_transcription if ":" in line])
        responses = [self.specialists.dispatch_task(task, full_transcript_text, video_path, video_analysis_map) for task in tasks]
        # Store full response objects for later analysis
        timeline = self._resolve_conflicts_and_build_timeline(responses, tasks)
        self.log_func(f"âœ… AI Director analysis complete. Generated {len(timeline)} timeline events.")
        return timeline

    def _event_driven_analysis(
        self,
        video_duration: float,
        audio_events: List[Dict]
    ) -> List[DirectorTask]:
        tasks = []
        window_size = 12.0
        step_size = 6.0
        for start_time in np.arange(0, video_duration - window_size, step_size):
            tasks.append(DirectorTask(task_type="analyze_text_content", time_range=(start_time, start_time + window_size), priority="medium", context={"video_duration": video_duration}))
        for event in audio_events:
            if event.get('tier') == 'major' or event.get('energy', 0) > 0.7:
                event_time_range = (event['start_time'], event['end_time'])
                tasks.append(DirectorTask(task_type="analyze_audio_event", time_range=event_time_range, priority="high", context=event))
                tasks.append(DirectorTask(task_type="analyze_visual_context", time_range=event_time_range, priority="high", context=event))
        return tasks

    def _resolve_conflicts_and_build_timeline(
        self,
        responses: List,
        tasks: List[DirectorTask]
    ) -> List[TimelineEvent]:
        # Pair events with their original responses and tasks for full context
        events_with_context = []
        if self.detailed_logs: self.log_func("\n--- AI Director: Specialist Responses ---")
        for response, task in zip(responses, tasks):
            if response.result != "no_significant_event" and response.recommended_action:
                duration = 2.0 if response.recommended_action == "zoom_to_cam_reaction" else 3.0
                event = TimelineEvent(timestamp=task.time_range[0], action=response.recommended_action, duration=duration, reason=response.result, confidence=response.confidence, source_task_id=response.task_id)
                events_with_context.append({"event": event, "response": response})
                if self.detailed_logs: self.log_func(f"  - Event Generated: {event.action} at {event.timestamp:.2f}s (Duration: {event.duration:.1f}s, Reason: {event.reason})")
        
        if not events_with_context:
            if self.detailed_logs: self.log_func("  - No significant events generated by specialists.")
            return []

        priority_map = {"dramatic_moment_visual": 3, "wild_content_detected": 2, "dramatic_moment_detected": 1, "awkward_content_detected": 1}
        # Sort by timestamp, then by priority
        events_with_context.sort(key=lambda x: (x['event'].timestamp, -priority_map.get(x['event'].reason, 0)))

        if self.detailed_logs: self.log_func("\n--- AI Director: Conflict Resolution & Sequencing ---")
        
        final_timeline_with_context = []
        i = 0
        while i < len(events_with_context):
            current_item = events_with_context[i]
            current_event = current_item["event"]

            # Action > Reaction Sequencing (remains the same)
            if (current_event.reason == "dramatic_moment_visual" and (i + 1) < len(events_with_context)):
                next_item = events_with_context[i+1]
                next_event = next_item["event"]
                if (next_event.action == "zoom_to_cam_reaction" and 
                    next_event.timestamp > current_event.timestamp and 
                    next_event.timestamp < current_event.timestamp + current_event.duration):
                    
                    if self.detailed_logs: self.log_func(f"  - Sequence Detected at {current_event.timestamp:.2f}s:")
                    current_event.duration = next_event.timestamp - current_event.timestamp
                    final_timeline_with_context.append(current_item)
                    final_timeline_with_context.append(next_item)
                    if self.detailed_logs: self.log_func(f"    - Resolution: Creating 'Action > Reaction' sequence.")
                    i += 2
                    continue

            # If no timeline yet, or no overlap
            if not final_timeline_with_context or current_event.timestamp >= final_timeline_with_context[-1]["event"].timestamp + final_timeline_with_context[-1]["event"].duration:
                if self.detailed_logs: self.log_func(f"  - No Conflict: Keeping {current_event.action} at {current_event.timestamp:.2f}s.")
                final_timeline_with_context.append(current_item)
            else:
                # CONFLICT DETECTED
                last_item = final_timeline_with_context[-1]
                last_event = last_item["event"]

                if self.detailed_logs:
                    self.log_func(f"  - Conflict Detected:")
                    self.log_func(f"    - Existing: {last_event.action} at {last_event.timestamp:.2f}s (Reason: {last_event.reason})")
                    self.log_func(f"    - New:      {current_event.action} at {current_event.timestamp:.2f}s (Reason: {current_event.reason})")

                # --- NEW EDITORIAL DECISION LOGIC ---
                # Identify which is the game event and which is the player event
                game_event_item = None
                player_event_item = None
                if "dramatic_moment" in last_event.reason: game_event_item = last_item
                if "dramatic_moment" in current_event.reason: game_event_item = current_item
                if "wild_content" in last_event.reason: player_event_item = last_item
                if "wild_content" in current_event.reason: player_event_item = current_item

                if game_event_item and player_event_item:
                    # Call the Editorial Specialist
                    decision = self.specialists.decide_editorial_priority(
                        game_event_details=game_event_item["response"].details,
                        player_event_details=player_event_item["response"].details
                    )
                    if decision == "game":
                        if self.detailed_logs: self.log_func(f"    - Resolution: Prioritizing 'game' event based on editorial decision.")
                        # Replace if the new event is the chosen game event
                        if current_item == game_event_item:
                            final_timeline_with_context[-1] = current_item
                    elif decision == "player":
                        if self.detailed_logs: self.log_func(f"    - Resolution: Prioritizing 'player' event based on editorial decision.")
                        # Replace if the new event is the chosen player event
                        if current_item == player_event_item:
                            final_timeline_with_context[-1] = current_item
                    else:
                        # Fallback to old priority system if specialist fails
                        if self.detailed_logs: self.log_func(f"    - Resolution: Editorial specialist failed, falling back to priority scores.")
                        current_priority = priority_map.get(current_event.reason, 0)
                        last_priority = priority_map.get(last_event.reason, 0)
                        if current_priority > last_priority:
                            final_timeline_with_context[-1] = current_item
                else:
                    # Standard priority conflict (e.g., two game events)
                    current_priority = priority_map.get(current_event.reason, 0)
                    last_priority = priority_map.get(last_event.reason, 0)
                    if current_priority > last_priority:
                        if self.detailed_logs: self.log_func(f"    - Resolution: Replacing with new event (Higher Priority).")
                        final_timeline_with_context[-1] = current_item
                    else:
                        if self.detailed_logs: self.log_func(f"    - Resolution: Keeping existing event (Higher or Equal Priority).")
            i += 1
                
        # Extract just the event objects for the final timeline
        return [item["event"] for item in final_timeline_with_context]